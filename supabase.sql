-- IcePulse Connect: schema, RLS, and storage policies

-- Extensions
create extension if not exists "pgcrypto";

-- Profiles (1:1 with auth.users)
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  role text check (role in ('Parent', 'Player')) default 'Parent',
  subscription_tier text default 'trial',
  trial_started_at timestamptz,
  trial_ends_at timestamptz,
  created_at timestamptz not null default now()
);

alter table public.profiles enable row level security;

create policy "Profiles are viewable by owner"
  on public.profiles for select
  using (auth.uid() = user_id);

create policy "Profiles are updatable by owner"
  on public.profiles for update
  using (auth.uid() = user_id);

-- Videos
create table if not exists public.videos (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  title text,
  original_filename text,
  storage_bucket text not null default 'videos',
  storage_path text not null,
  external_video_url text,
  matching_video_url text,
  game_date date,
  team_name text,
  opponent_name text,
  file_size bigint,
  file_last_modified bigint,
  duration_seconds double precision,
  status text not null default 'uploaded',
  created_at timestamptz not null default now(),
  updated_at timestamptz
);

alter table public.videos enable row level security;

create policy "Videos are viewable by owner"
  on public.videos for select
  using (auth.uid() = user_id);

create policy "Videos are insertable by owner"
  on public.videos for insert
  with check (auth.uid() = user_id);

create policy "Videos are updatable by owner"
  on public.videos for update
  using (auth.uid() = user_id);

create policy "Videos are deletable by owner"
  on public.videos for delete
  using (auth.uid() = user_id);

-- Events
create table if not exists public.events (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  video_id uuid not null references public.videos(id) on delete cascade,
  event_type text not null,
  note text,
  player_number text,
  video_time_seconds double precision not null default 0,
  ice_x double precision,
  ice_y double precision,
  goal_x double precision,
  goal_y double precision,
  created_at timestamptz not null default now(),
  updated_at timestamptz
);

alter table public.events enable row level security;

create policy "Events are viewable by owner"
  on public.events for select
  using (auth.uid() = user_id);

create policy "Events are insertable by owner"
  on public.events for insert
  with check (auth.uid() = user_id);

create policy "Events are updatable by owner"
  on public.events for update
  using (auth.uid() = user_id);

create policy "Events are deletable by owner"
  on public.events for delete
  using (auth.uid() = user_id);

-- Clips (generated by pipeline)
create table if not exists public.clips (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  video_id uuid not null references public.videos(id) on delete cascade,
  event_id uuid references public.events(id) on delete set null,
  storage_bucket text not null default 'clips',
  storage_path text,
  start_time_seconds double precision not null default 0,
  end_time_seconds double precision not null default 0,
  status text not null default 'queued',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.clips enable row level security;

create policy "Clips are viewable by owner"
  on public.clips for select
  using (auth.uid() = user_id);

create policy "Clips are insertable by owner"
  on public.clips for insert
  with check (auth.uid() = user_id);

create policy "Clips are updatable by owner"
  on public.clips for update
  using (auth.uid() = user_id);

create policy "Clips are deletable by owner"
  on public.clips for delete
  using (auth.uid() = user_id);

-- Updated_at trigger for clips
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Updated_at trigger for videos
drop trigger if exists set_videos_updated_at on public.videos;
create trigger set_videos_updated_at
before update on public.videos
for each row execute procedure public.set_updated_at();

-- Updated_at trigger for events
drop trigger if exists set_events_updated_at on public.events;
create trigger set_events_updated_at
before update on public.events
for each row execute procedure public.set_updated_at();

drop trigger if exists set_clips_updated_at on public.clips;
create trigger set_clips_updated_at
before update on public.clips
for each row execute procedure public.set_updated_at();

-- Create profile on auth.user signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (
    user_id,
    full_name,
    role,
    subscription_tier,
    trial_started_at,
    trial_ends_at
  )
  values (
    new.id,
    coalesce(new.raw_user_meta_data->>'full_name', ''),
    coalesce(new.raw_user_meta_data->>'role', 'Parent'),
    'trial',
    now(),
    now() + interval '7 days'
  )
  on conflict (user_id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();

-- Clip request trigger (queue a clip for each event)
create or replace function public.queue_clip_on_event()
returns trigger as $$
declare
  start_time double precision;
  end_time double precision;
begin
  start_time := greatest(new.video_time_seconds - 5, 0);
  end_time := new.video_time_seconds + 5;

  insert into public.clips (
    user_id,
    video_id,
    event_id,
    start_time_seconds,
    end_time_seconds,
    status
  )
  values (
    new.user_id,
    new.video_id,
    new.id,
    start_time,
    end_time,
    'queued'
  );

  return new;
end;
$$ language plpgsql;

drop trigger if exists queue_clip_after_event on public.events;
create trigger queue_clip_after_event
after insert on public.events
for each row execute procedure public.queue_clip_on_event();

-- Storage buckets (run once)
insert into storage.buckets (id, name, public)
values ('videos', 'videos', false)
on conflict (id) do nothing;

insert into storage.buckets (id, name, public)
values ('clips', 'clips', false)
on conflict (id) do nothing;

-- Storage policies
create policy "Users can manage their videos"
  on storage.objects for all
  using (bucket_id = 'videos' and auth.uid() = owner)
  with check (bucket_id = 'videos' and auth.uid() = owner);

create policy "Users can manage their clips"
  on storage.objects for all
  using (bucket_id = 'clips' and auth.uid() = owner)
  with check (bucket_id = 'clips' and auth.uid() = owner);

-- Player codes and parent-player links
alter table public.profiles
  add column if not exists player_code text;

create unique index if not exists profiles_player_code_idx
  on public.profiles (player_code)
  where player_code is not null;

create table if not exists public.parent_player_links (
  id uuid primary key default gen_random_uuid(),
  parent_user_id uuid not null references auth.users(id) on delete cascade,
  player_user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  unique (parent_user_id, player_user_id)
);

alter table public.parent_player_links
  add constraint parent_player_links_parent_profile_fkey
  foreign key (parent_user_id) references public.profiles(user_id) on delete cascade;

alter table public.parent_player_links
  add constraint parent_player_links_player_profile_fkey
  foreign key (player_user_id) references public.profiles(user_id) on delete cascade;

alter table public.parent_player_links enable row level security;

create policy "Parent-player links viewable by linked users"
  on public.parent_player_links for select
  using (auth.uid() = parent_user_id or auth.uid() = player_user_id);

create policy "Parents can link players"
  on public.parent_player_links for insert
  with check (auth.uid() = parent_user_id);

create policy "Parents can remove links"
  on public.parent_player_links for delete
  using (auth.uid() = parent_user_id);

create policy "Profiles viewable by linked users"
  on public.profiles for select
  using (
    auth.uid() = user_id
    or exists (
      select 1 from public.parent_player_links ppl
      where (ppl.parent_user_id = auth.uid() and ppl.player_user_id = user_id)
         or (ppl.player_user_id = auth.uid() and ppl.parent_user_id = user_id)
    )
  );

create or replace function public.assign_player_code()
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  new_code text;
  attempts int := 0;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  if not exists (select 1 from public.profiles where user_id = auth.uid()) then
    raise exception 'Profile missing';
  end if;

  if (select role from public.profiles where user_id = auth.uid()) <> 'Player' then
    raise exception 'Only players can have codes';
  end if;

  if (select player_code from public.profiles where user_id = auth.uid()) is not null then
    return (select player_code from public.profiles where user_id = auth.uid());
  end if;

  loop
    new_code := upper(substr(encode(gen_random_bytes(4), 'hex'), 1, 6));
    exit when not exists (select 1 from public.profiles where player_code = new_code);
    attempts := attempts + 1;
    if attempts > 10 then
      raise exception 'Unable to generate unique code';
    end if;
  end loop;

  update public.profiles
    set player_code = new_code
    where user_id = auth.uid();

  return new_code;
end;
$$;

create or replace function public.link_player_by_code(code text)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  player_id uuid;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  select user_id into player_id
    from public.profiles
    where player_code = upper(code)
      and role = 'Player';

  if player_id is null then
    raise exception 'Invalid code';
  end if;

  insert into public.parent_player_links (parent_user_id, player_user_id)
  values (auth.uid(), player_id)
  on conflict do nothing;

  return player_id;
end;
$$;

grant execute on function public.assign_player_code() to authenticated;
grant execute on function public.link_player_by_code(text) to authenticated;
